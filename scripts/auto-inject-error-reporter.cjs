#!/usr/bin/env node
/**
 * üöÄ AUTO-INJECT ERROR REPORTER
 * T·ª± ƒë·ªông c√†i ƒë·∫∑t error tracking v√†o T·∫§T C·∫¢ c√°c project
 * 
 * Ch·∫°y: node scripts/auto-inject-error-reporter.cjs
 */

const fs = require('fs');
const path = require('path');

// ============================================
// CONFIG
// ============================================
const LONGSANG_ADMIN_URL = 'https://longsang-admin.vercel.app';
const PROJECTS_ROOT = 'D:\\0.PROJECTS';

const TARGET_PROJECTS = [
  { path: '01-MAIN-PRODUCTS/ainewbie-web', name: 'ainewbie-web' },
  { path: '01-MAIN-PRODUCTS/music-video-app', name: 'music-video-app' },
  { path: '01-MAIN-PRODUCTS/vungtau-dream-homes', name: 'vungtau-dream-homes' },
  { path: '01-MAIN-PRODUCTS/long-sang-forge', name: 'long-sang-forge' },
  { path: '01-MAIN-PRODUCTS/ai_secretary', name: 'ai_secretary' },
  { path: '02-SABO-ECOSYSTEM/sabo-arena', name: 'sabo-arena' },
  { path: '02-SABO-ECOSYSTEM/sabo-hub', name: 'sabo-hub' },
];

// ============================================
// ERROR REPORTER CODE
// ============================================
const ERROR_REPORTER_CODE = `/**
 * üî¥ LONGSANG ERROR REPORTER
 * Auto-reports errors to longsang-admin for auto-fix
 * Generated by auto-inject-error-reporter.cjs
 */

const ADMIN_URL = '${LONGSANG_ADMIN_URL}';
const APP_NAME = '%APP_NAME%';

class ErrorReporter {
  private static instance: ErrorReporter;
  private errorQueue: any[] = [];
  private isProcessing = false;

  static getInstance() {
    if (!this.instance) {
      this.instance = new ErrorReporter();
    }
    return this.instance;
  }

  constructor() {
    this.setupGlobalHandlers();
    this.startQueueProcessor();
  }

  private setupGlobalHandlers() {
    // Catch unhandled errors
    if (typeof window !== 'undefined') {
      window.onerror = (message, source, lineno, colno, error) => {
        this.reportError({
          type: error?.name || 'Error',
          message: String(message),
          stack: error?.stack,
          file: source,
          line: lineno,
          column: colno,
        });
        return false;
      };

      // Catch unhandled promise rejections
      window.onunhandledrejection = (event) => {
        this.reportError({
          type: 'UnhandledPromiseRejection',
          message: event.reason?.message || String(event.reason),
          stack: event.reason?.stack,
        });
      };

      // Catch React errors
      const originalConsoleError = console.error;
      console.error = (...args) => {
        const message = args.map(a => String(a)).join(' ');
        if (message.includes('Error') || message.includes('error')) {
          this.reportError({
            type: 'ConsoleError',
            message: message.slice(0, 500),
          });
        }
        originalConsoleError.apply(console, args);
      };
    }
  }

  reportError(errorData: {
    type: string;
    message: string;
    stack?: string;
    file?: string;
    line?: number;
    column?: number;
  }) {
    // Extract file and line from stack if not provided
    let file = errorData.file;
    let line = errorData.line;
    
    if (!file && errorData.stack) {
      const stackMatch = errorData.stack.match(/at\\s+.*?\\((.*?):(\\d+):(\\d+)\\)/);
      if (stackMatch) {
        file = stackMatch[1];
        line = parseInt(stackMatch[2]);
      }
    }

    this.errorQueue.push({
      app: APP_NAME,
      type: errorData.type,
      message: errorData.message,
      file: file || 'unknown',
      line: line || 0,
      stack: errorData.stack,
      timestamp: new Date().toISOString(),
      url: typeof window !== 'undefined' ? window.location.href : '',
      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
    });
  }

  private async startQueueProcessor() {
    setInterval(async () => {
      if (this.isProcessing || this.errorQueue.length === 0) return;
      
      this.isProcessing = true;
      const errors = [...this.errorQueue];
      this.errorQueue = [];

      try {
        for (const error of errors) {
          await fetch(\`\${ADMIN_URL}/api/errors/report\`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(error),
          }).catch(() => {}); // Silent fail
        }
      } finally {
        this.isProcessing = false;
      }
    }, 5000); // Send every 5 seconds
  }

  // Manual error capture
  capture(error: Error, context?: Record<string, any>) {
    this.reportError({
      type: error.name,
      message: error.message,
      stack: error.stack,
      ...context,
    });
  }
}

// Initialize and export
export const errorReporter = ErrorReporter.getInstance();

// For manual capture: errorReporter.capture(new Error('test'))
export default errorReporter;
`;

// ============================================
// MAIN ENTRY CODE
// ============================================
const MAIN_ENTRY_IMPORT = `import './lib/error-reporter';`;

// ============================================
// FUNCTIONS
// ============================================

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function findEntryFile(projectPath) {
  const candidates = [
    'src/main.tsx',
    'src/main.ts',
    'src/index.tsx',
    'src/index.ts',
    'src/App.tsx',
    'app/layout.tsx', // Next.js
    'pages/_app.tsx', // Next.js pages
  ];

  for (const candidate of candidates) {
    const fullPath = path.join(projectPath, candidate);
    if (fs.existsSync(fullPath)) {
      return { path: fullPath, relative: candidate };
    }
  }
  return null;
}

function injectErrorReporter(project) {
  const projectPath = path.join(PROJECTS_ROOT, project.path);
  
  if (!fs.existsSync(projectPath)) {
    console.log(`‚è≠Ô∏è  Skip: ${project.name} (kh√¥ng t·ªìn t·∫°i)`);
    return { success: false, reason: 'not-found' };
  }

  // 1. Create error-reporter.ts in src/lib/
  const libDir = path.join(projectPath, 'src', 'lib');
  ensureDir(libDir);

  const reporterPath = path.join(libDir, 'error-reporter.ts');
  const reporterCode = ERROR_REPORTER_CODE.replace(/%APP_NAME%/g, project.name);
  
  fs.writeFileSync(reporterPath, reporterCode);
  console.log(`‚úÖ Created: ${project.name}/src/lib/error-reporter.ts`);

  // 2. Find and modify entry file
  const entryFile = findEntryFile(projectPath);
  if (!entryFile) {
    console.log(`‚ö†Ô∏è  ${project.name}: Kh√¥ng t√¨m th·∫•y entry file`);
    return { success: true, reason: 'no-entry', created: reporterPath };
  }

  // Check if already imported
  let entryContent = fs.readFileSync(entryFile.path, 'utf-8');
  if (entryContent.includes('error-reporter')) {
    console.log(`‚úÖ ${project.name}: ƒê√£ c√≥ import error-reporter`);
    return { success: true, reason: 'already-imported' };
  }

  // Add import at the very top (after any 'use client' directive)
  const useClientMatch = entryContent.match(/^(['"]use client['"];?\n?)/);
  if (useClientMatch) {
    entryContent = useClientMatch[0] + MAIN_ENTRY_IMPORT + '\n' + entryContent.slice(useClientMatch[0].length);
  } else {
    entryContent = MAIN_ENTRY_IMPORT + '\n' + entryContent;
  }

  fs.writeFileSync(entryFile.path, entryContent);
  console.log(`‚úÖ Injected import into: ${project.name}/${entryFile.relative}`);

  return { success: true, entry: entryFile.relative };
}

// ============================================
// MAIN
// ============================================
console.log('üöÄ AUTO-INJECT ERROR REPORTER');
console.log('='.repeat(50));
console.log(`Target: ${LONGSANG_ADMIN_URL}/api/errors/report`);
console.log(`Projects: ${TARGET_PROJECTS.length}`);
console.log('='.repeat(50));
console.log('');

const results = {
  success: [],
  skipped: [],
  failed: [],
};

for (const project of TARGET_PROJECTS) {
  try {
    const result = injectErrorReporter(project);
    if (result.success) {
      results.success.push(project.name);
    } else {
      results.skipped.push(project.name);
    }
  } catch (error) {
    console.error(`‚ùå ${project.name}: ${error.message}`);
    results.failed.push(project.name);
  }
}

console.log('');
console.log('='.repeat(50));
console.log('üìä K·∫æT QU·∫¢:');
console.log(`‚úÖ Th√†nh c√¥ng: ${results.success.length} (${results.success.join(', ')})`);
console.log(`‚è≠Ô∏è  B·ªè qua: ${results.skipped.length} (${results.skipped.join(', ')})`);
console.log(`‚ùå Th·∫•t b·∫°i: ${results.failed.length} (${results.failed.join(', ')})`);
console.log('='.repeat(50));
console.log('');
console.log('üéØ NEXT STEPS:');
console.log('1. Commit & push c√°c project ƒë√£ inject');
console.log('2. Deploy l·∫°i c√°c project');
console.log('3. Khi c√≥ l·ªói th·∫≠t ‚Üí T·ª± ƒë·ªông g·ª≠i v·ªÅ longsang-admin ‚Üí T·ª± ƒë·ªông t·∫°o Issue');
