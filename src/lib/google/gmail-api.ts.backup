/**
 * Gmail API - Email Automation
 * G·ª≠i emails th·∫≠t qua Gmail v·ªõi Service Account
 */

import { google } from 'googleapis';
import { supabase } from '@/integrations/supabase/client';

const SCOPES = ['https://www.googleapis.com/auth/gmail.send'];

/**
 * Get authenticated Gmail client
 */
function getGmailClient(userEmail: string) {
  const credentials = JSON.parse(import.meta.env.VITE_GOOGLE_SERVICE_ACCOUNT_KEY || '{}');
  
  const auth = new google.auth.GoogleAuth({
    credentials,
    scopes: SCOPES,
    // Subject: Email account to impersonate (c·∫ßn domain-wide delegation)
    clientOptions: {
      subject: userEmail,
    },
  });

  return google.gmail({ version: 'v1', auth });
}

export interface EmailOptions {
  to: string | string[];
  subject: string;
  body: string;
  html?: string;
  cc?: string[];
  bcc?: string[];
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content: string; // base64
    mimeType: string;
  }>;
}

export interface EmailResult {
  status: 'success' | 'error';
  messageId?: string;
  message: string;
  timestamp: string;
}

// ============================================================
// SEND EMAILS
// ============================================================

/**
 * üìß Send email via Gmail
 * ACTION: G·ª≠i email th·∫≠t ƒë·∫øn inbox ng∆∞·ªùi nh·∫≠n
 */
export async function sendEmail(
  fromEmail: string,
  options: EmailOptions
): Promise<EmailResult> {
  try {
    const gmail = getGmailClient(fromEmail);

    // Build email message
    const message = createEmailMessage(fromEmail, options);
    const encodedMessage = Buffer.from(message)
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');

    // Send email
    const response = await gmail.users.messages.send({
      userId: 'me',
      requestBody: {
        raw: encodedMessage,
      },
    });

    const result: EmailResult = {
      status: 'success',
      messageId: response.data.id,
      message: 'Email sent successfully',
      timestamp: new Date().toISOString(),
    };

    // Log to database
    await logEmailAction(result, options);

    return result;
  } catch (error) {
    const result: EmailResult = {
      status: 'error',
      message: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString(),
    };

    await logEmailAction(result, options);
    throw error;
  }
}

/**
 * Create RFC 2822 formatted email message
 */
function createEmailMessage(from: string, options: EmailOptions): string {
  const to = Array.isArray(options.to) ? options.to.join(', ') : options.to;
  const cc = options.cc?.join(', ') || '';
  const bcc = options.bcc?.join(', ') || '';
  
  const boundary = '----=_Part_0_' + Date.now();
  
  let message = [
    `From: ${from}`,
    `To: ${to}`,
    cc ? `Cc: ${cc}` : '',
    bcc ? `Bcc: ${bcc}` : '',
    options.replyTo ? `Reply-To: ${options.replyTo}` : '',
    `Subject: ${options.subject}`,
    'MIME-Version: 1.0',
    `Content-Type: multipart/alternative; boundary="${boundary}"`,
    '',
    `--${boundary}`,
    'Content-Type: text/plain; charset=UTF-8',
    '',
    options.body,
    '',
  ];

  if (options.html) {
    message = message.concat([
      `--${boundary}`,
      'Content-Type: text/html; charset=UTF-8',
      '',
      options.html,
      '',
    ]);
  }

  if (options.attachments) {
    for (const attachment of options.attachments) {
      message = message.concat([
        `--${boundary}`,
        `Content-Type: ${attachment.mimeType}`,
        'Content-Transfer-Encoding: base64',
        `Content-Disposition: attachment; filename="${attachment.filename}"`,
        '',
        attachment.content,
        '',
      ]);
    }
  }

  message.push(`--${boundary}--`);

  return message.filter(line => line !== null).join('\r\n');
}

// ============================================================
// EMAIL TEMPLATES
// ============================================================

/**
 * üìß Send consultation confirmation email
 */
export async function sendConsultationConfirmation(
  fromEmail: string,
  consultation: {
    customerEmail: string;
    customerName: string;
    date: string;
    time: string;
    service: string;
  }
): Promise<EmailResult> {
  const subject = `X√°c nh·∫≠n l·ªãch t∆∞ v·∫•n - ${consultation.service}`;
  
  const body = `
Xin ch√†o ${consultation.customerName},

C·∫£m ∆°n b·∫°n ƒë√£ ƒë·∫∑t l·ªãch t∆∞ v·∫•n v·ªõi ch√∫ng t√¥i.

TH√îNG TIN L·ªäCH H·∫∏N:
- D·ªãch v·ª•: ${consultation.service}
- Ng√†y: ${consultation.date}
- Gi·ªù: ${consultation.time}

Ch√∫ng t√¥i s·∫Ω li√™n h·ªá v·ªõi b·∫°n tr∆∞·ªõc gi·ªù h·∫πn 15 ph√∫t.

Tr√¢n tr·ªçng,
Long Sang Team
  `.trim();

  const html = `
    <html>
      <body style="font-family: Arial, sans-serif; line-height: 1.6;">
        <h2 style="color: #2563eb;">X√°c nh·∫≠n l·ªãch t∆∞ v·∫•n</h2>
        <p>Xin ch√†o <strong>${consultation.customerName}</strong>,</p>
        <p>C·∫£m ∆°n b·∫°n ƒë√£ ƒë·∫∑t l·ªãch t∆∞ v·∫•n v·ªõi ch√∫ng t√¥i.</p>
        
        <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="margin-top: 0;">TH√îNG TIN L·ªäCH H·∫∏N</h3>
          <p><strong>D·ªãch v·ª•:</strong> ${consultation.service}</p>
          <p><strong>Ng√†y:</strong> ${consultation.date}</p>
          <p><strong>Gi·ªù:</strong> ${consultation.time}</p>
        </div>
        
        <p>Ch√∫ng t√¥i s·∫Ω li√™n h·ªá v·ªõi b·∫°n tr∆∞·ªõc gi·ªù h·∫πn 15 ph√∫t.</p>
        
        <p style="margin-top: 30px;">
          Tr√¢n tr·ªçng,<br>
          <strong>Long Sang Team</strong>
        </p>
      </body>
    </html>
  `;

  return sendEmail(fromEmail, {
    to: consultation.customerEmail,
    subject,
    body,
    html,
  });
}

/**
 * üìß Send newsletter email
 */
export async function sendNewsletter(
  fromEmail: string,
  subscribers: string[],
  newsletter: {
    subject: string;
    content: string;
    htmlContent?: string;
  }
): Promise<EmailResult[]> {
  const results: EmailResult[] = [];

  for (const subscriber of subscribers) {
    try {
      const result = await sendEmail(fromEmail, {
        to: subscriber,
        subject: newsletter.subject,
        body: newsletter.content,
        html: newsletter.htmlContent,
      });
      results.push(result);
    } catch (error) {
      results.push({
        status: 'error',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      });
    }
  }

  return results;
}

/**
 * üìß Send welcome email for new users
 */
export async function sendWelcomeEmail(
  fromEmail: string,
  userEmail: string,
  userName: string
): Promise<EmailResult> {
  const subject = 'Ch√†o m·ª´ng ƒë·∫øn v·ªõi Long Sang!';
  
  const body = `
Xin ch√†o ${userName},

Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Long Sang!

Ch√∫ng t√¥i r·∫•t vui khi b·∫°n tham gia c·ªông ƒë·ªìng c·ªßa ch√∫ng t√¥i.

B∆Ø·ªöC TI·∫æP THEO:
1. Ho√†n thi·ªán h·ªì s∆° c√° nh√¢n
2. Kh√°m ph√° c√°c d·ªãch v·ª• c·ªßa ch√∫ng t√¥i
3. ƒê·∫∑t l·ªãch t∆∞ v·∫•n mi·ªÖn ph√≠

N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o, ƒë·ª´ng ng·∫°i li√™n h·ªá v·ªõi ch√∫ng t√¥i.

Tr√¢n tr·ªçng,
Long Sang Team
  `.trim();

  const html = `
    <html>
      <body style="font-family: Arial, sans-serif; line-height: 1.6;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h1 style="color: #2563eb; text-align: center;">Ch√†o m·ª´ng ƒë·∫øn v·ªõi Long Sang!</h1>
          
          <p>Xin ch√†o <strong>${userName}</strong>,</p>
          <p>Ch√∫ng t√¥i r·∫•t vui khi b·∫°n tham gia c·ªông ƒë·ªìng c·ªßa ch√∫ng t√¥i.</p>
          
          <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">B∆Ø·ªöC TI·∫æP THEO</h3>
            <ol>
              <li>Ho√†n thi·ªán h·ªì s∆° c√° nh√¢n</li>
              <li>Kh√°m ph√° c√°c d·ªãch v·ª• c·ªßa ch√∫ng t√¥i</li>
              <li>ƒê·∫∑t l·ªãch t∆∞ v·∫•n mi·ªÖn ph√≠</li>
            </ol>
          </div>
          
          <p>N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o, ƒë·ª´ng ng·∫°i li√™n h·ªá v·ªõi ch√∫ng t√¥i.</p>
          
          <p style="margin-top: 30px; text-align: center;">
            Tr√¢n tr·ªçng,<br>
            <strong>Long Sang Team</strong>
          </p>
        </div>
      </body>
    </html>
  `;

  return sendEmail(fromEmail, {
    to: userEmail,
    subject,
    body,
    html,
  });
}

// ============================================================
// AUTO-SEND WORKFLOWS
// ============================================================

/**
 * üî• Auto-send emails for new consultations
 */
export async function autoSendConsultationEmails(fromEmail: string) {
  try {
    // Get consultations without confirmation email
    const { data: consultations, error } = await supabase
      .from('consultations')
      .select('*')
      .eq('confirmation_sent', false)
      .limit(50);

    if (error) throw error;

    if (!consultations || consultations.length === 0) {
      return {
        status: 'success',
        message: 'No pending consultations',
        sent: 0,
      };
    }

    const results: EmailResult[] = [];

    for (const consultation of consultations) {
      try {
        const result = await sendConsultationConfirmation(fromEmail, {
          customerEmail: consultation.email,
          customerName: consultation.name,
          date: new Date(consultation.consultation_date).toLocaleDateString('vi-VN'),
          time: consultation.consultation_time,
          service: consultation.service_type,
        });

        results.push(result);

        // Update confirmation_sent
        if (result.status === 'success') {
          await supabase
            .from('consultations')
            .update({ confirmation_sent: true })
            .eq('id', consultation.id);
        }
      } catch (error) {
        console.error(`Failed to send email for consultation ${consultation.id}:`, error);
      }
    }

    const successful = results.filter(r => r.status === 'success').length;

    return {
      status: 'success',
      message: `Sent ${successful} out of ${consultations.length} confirmation emails`,
      sent: successful,
      failed: consultations.length - successful,
      results,
    };
  } catch (error) {
    throw new Error(`Auto-send failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// ============================================================
// LOGGING
// ============================================================

async function logEmailAction(result: EmailResult, options: EmailOptions) {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    await supabase.from('google_sync_logs').insert({
      user_id: user?.id,
      service: 'gmail',
      operation: 'send_email',
      status: result.status,
      records_synced: 1,
      error_message: result.message,
      metadata: {
        to: options.to,
        subject: options.subject,
        messageId: result.messageId,
      },
    });
  } catch (error) {
    console.error('Failed to log email action:', error);
  }
}

/**
 * Get email sending history
 */
export async function getEmailHistory(limit: number = 50) {
  try {
    const { data, error } = await supabase
      .from('google_sync_logs')
      .select('*')
      .eq('service', 'gmail')
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) throw error;

    return data || [];
  } catch (error) {
    throw new Error(`Failed to get email history: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Get email stats
 */
export async function getEmailStats(days: number = 7) {
  try {
    const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString();

    const { data, error } = await supabase
      .from('google_sync_logs')
      .select('status, records_synced')
      .eq('service', 'gmail')
      .gte('created_at', since);

    if (error) throw error;

    const stats = {
      total: data?.length || 0,
      successful: data?.filter(d => d.status === 'success').length || 0,
      failed: data?.filter(d => d.status === 'error').length || 0,
    };

    return stats;
  } catch (error) {
    throw new Error(`Failed to get stats: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
